{"id":"00893","group":"easy-ham-1","checksum":{"type":"MD5","value":"6edf02e68e0e172b2142e5a75d467057"},"text":"From fork-admin@xent.com  Sat Oct  5 17:22:20 2002\nReturn-Path: <fork-admin@xent.com>\nDelivered-To: yyyy@localhost.spamassassin.taint.org\nReceived: from localhost (jalapeno [127.0.0.1])\n\tby jmason.org (Postfix) with ESMTP id 6DB7B16F16\n\tfor <jm@localhost>; Sat,  5 Oct 2002 17:22:16 +0100 (IST)\nReceived: from jalapeno [127.0.0.1]\n\tby localhost with IMAP (fetchmail-5.9.0)\n\tfor jm@localhost (single-drop); Sat, 05 Oct 2002 17:22:16 +0100 (IST)\nReceived: from xent.com ([64.161.22.236]) by dogma.slashnull.org\n    (8.11.6/8.11.6) with ESMTP id g95E6SK11973 for <jm@jmason.org>;\n    Sat, 5 Oct 2002 15:06:30 +0100\nReceived: from lair.xent.com (localhost [127.0.0.1]) by xent.com (Postfix)\n    with ESMTP id 246ED29418A; Sat,  5 Oct 2002 07:06:03 -0700 (PDT)\nDelivered-To: fork@spamassassin.taint.org\nReceived: from mta5.snfc21.pbi.net (mta5.snfc21.pbi.net [206.13.28.241])\n    by xent.com (Postfix) with ESMTP id 4673F29409A for <fork@xent.com>;\n    Sat,  5 Oct 2002 07:05:41 -0700 (PDT)\nReceived: from endeavors.com ([66.126.120.174]) by mta5.snfc21.pbi.net\n    (iPlanet Messaging Server 5.1 (built May  7 2001)) with ESMTP id\n    <0H3I00GDEHTZ6T@mta5.snfc21.pbi.net> for fork@xent.com; Sat,\n    05 Oct 2002 07:06:00 -0700 (PDT)\nFrom: Gregory Alan Bolcer <gbolcer@endeavors.com>\nSubject: Re: Apple Sauced...again\nCc: fork@spamassassin.taint.org\nReply-To: gbolcer@endeavors.com\nMessage-Id: <3D9EEF77.CBAE56C@endeavors.com>\nOrganization: Endeavors Technology, Inc.\nMIME-Version: 1.0\nX-Mailer: Mozilla 4.79 [en] (X11; U; IRIX 6.5 IP32)\nContent-Type: text/plain; charset=us-ascii\nContent-Transfer-Encoding: 7bit\nX-Accept-Language: en, pdf\nReferences: <Pine.BSO.4.44.0210021830180.7029-100000@crank.slack.net>\n    <200210022317.13639.eh@mad.scientist.com> <m2k7l0nltn.fsf@maya.dyndns.org>\n    <p05111a45b9c1d8f5291b@[66.149.49.6]> <m23crnmvom.fsf@maya.dyndns.org>\nSender: fork-admin@xent.com\nErrors-To: fork-admin@xent.com\nX-Beenthere: fork@spamassassin.taint.org\nX-Mailman-Version: 2.0.11\nPrecedence: bulk\nList-Help: <mailto:fork-request@xent.com?subject=help>\nList-Post: <mailto:fork@spamassassin.taint.org>\nList-Subscribe: <http://xent.com/mailman/listinfo/fork>, <mailto:fork-request@xent.com?subject=subscribe>\nList-Id: Friends of Rohit Khare <fork.xent.com>\nList-Unsubscribe: <http://xent.com/mailman/listinfo/fork>,\n    <mailto:fork-request@xent.com?subject=unsubscribe>\nList-Archive: <http://xent.com/pipermail/fork/>\nDate: Sat, 05 Oct 2002 06:56:07 -0700\n\nGary Lawrence Murphy wrote:\n> R. Buckminster Fuller\n> \n> \"It was only /after/ I'd completed the geodesic dome that I noticed it\n> was beautiful\" --- R. Buckminster Fuller\n\n\nI had cited the information theoretic concept of \"elegance\"\nin my dissertation & did a Google to find the reference and instead\nfound a really great tech report for UoT Knoxville by Bruce\nMacLennan.  He cites Efficiency, Economy, and Elegance, but\nI think he's wrong.  The middle E should be Effectiveness. \nOtherwise kudos.\n\n\nEfficiency is the relation of output to input effectiveness is\nthe total output.  In information theory, something is both elegant\nand efficient if no smaller or less costly something can product the \nsame output in the same amount of time. \n\nGreg\n\n[1] http://www.cs.utk.edu/~mclennan/anon-ftp/Elegance.html\n\n``Who Cares About Elegance?''\n\n        The Role of Aesthetics in Programming Language Design \n\n                           Technical Report UT-CS-97-344\n\n                                 Bruce J. MacLennan\n\n                            Computer Science Department\n                           University of Tennessee, Knoxville\n                               MacLennan@cs.utk.edu \n\nAbstract\n\nThe crucial role played by aesthetics in programming language design and the importance of elegance in\nprogramming languages are defended on the basis of analogies with structural engineering, as presented in\nBillington's The Tower and the Bridge. \n\nThis report may be used for any nonprofit purpose provided that its source is acknowledged. It will be adapted\nfor\ninclusion in the third edition of my Principles of Programming Languages. \n\n\n   1.The Value of Analogies \n   2.Efficiency Seeks to Minimize Resources Used \n   3.Economy Seeks to Maximize Benefit versus Cost \n   4.Elegance Symbolizes Good Design \n       1.For the Designer \n       2.For the User \n   5.The Programming Language as Work Environment \n   6.Acquiring a Sense of Elegance \n   7.References \n\n\n\nThe Value of Analogies\n\nProgramming language design is a comparatively new activity - it has existed for less than half a century, so\nit is\noften worthwhile to look to older design disciplines to understand better this new activity. Thus, my book\nPrinciples of Programming Languages: Design, Evaluation, and Implementation, grew out of a study of teaching\nmethods in architecture, primarily, but also of pedagogy in other disciplines, such as aircraft design.\nPerhaps you\nhave also seen analogies drawn between programming languages and cars (FORTRAN = Model T, C = dune\nbuggy, etc.). \n\nThese analogies can be very informative, and can serve as ``intuition pumps'' to enhance our creativity, but\nthey\ncannot be used uncritically because they are, in the end, just analogies. Ultimately our design decisions must\nbe\nbased on more than analogies, since analogies can be misleading as well as informative. \n\nIn this essay I'll address the role of aesthetics in programming language design, but I will base my remarks\non a\nbook about structural engineering, The Tower and the Bridge, by David P. Billington. Although there are many\ndifferences between bridges and programming languages, we will find that many ideas and insights transfer\nrather\ndirectly. \n\nAccording to Billington, there are three values common to many technological activities, which we can call\n``the\nthree E's'': Efficiency, Economy and Elegance. These values correspond to three dimensions of technology,\nwhich\nBillington calls the scientific, social and symbolic dimensions (the three S's). We will consider each in\nturn. \n\n\nEfficiency Seeks to Minimize Resources Used\n\nIn structural engineering, efficiency deals with the amount of material used; the basic criterion is safety\nand the\nissues are scientific (strength of materials, disposition of forces, etc.). Similarly, in programming language\ndesign,\nefficiency is a scientific question dealing with the use of resources. There are many examples where\nefficiency\nconsiderations influenced programming language design (some are reviewed in my Principles of Programming\nLanguages). In the early days, the resources to be minimized were often runtime memory usage and processing\ntime, although compile-time resource utilization was also relevant. In other cases the resource economized was\nprogrammer typing time, and there are well-known cases in which this compromised safety (e.g. FORTRAN's\nimplicit declarations). There are also many well-known cases in which security (i.e. safety) was sacrificed\nfor the\nsake of efficiency by neglecting runtime error checking (e.g. array bounds checking). \n\nEfficiency issues often can be quantified in terms of computer memory or time, but we must be careful that we\nare\nnot comparing apples and oranges. Compile time is not interchangeable run time, and neither one is the same as\nprogrammer time. Similarly, computer memory cannot be traded off against computer time unless both are\nreduced to a common denominator, such as money, but this brings in economic considerations, to which we now\nturn. \n\n\nEconomy Seeks to Maximize Benefit versus Cost\n\nWhereas efficiency is a scientific issue, economy is a social issue. In structural engineering, economy seeks\nto\nmaximize social benefit compared to its cost. (This is especially appropriate since structures like bridges\nare\nusually built at public expense for the benefit of the public.) In programming language design, the ``public''\nthat\nmust be satisfied is the programming community that will use the language and the institutions for which these\nprogrammers work. \n\nEconomic tradeoffs are hard to make because economic values change and are difficult to predict. For example,\nthe shift from first to second generation programming languages was largely a result of a decrease in the cost\nof\ncomputer time compared to programmer time, the shift from the second to the third generation involved the\nincreasing cost of residual bugs in programs, and the fourth generation reflected the increasing cost of\nprogram\nmaintenance compared to program development. \n\nOther social factors involved in the success or failure of a programming language include: whether major\nmanufacturers support the language, whether prestigious universities teach it, whether it is approved in some\nway\nby influential organizations (such as the US Department of Defense), whether it has been standardized, whether\nit\ncomes to be perceived as a ``real'' language (used by ``real programmers'') or as a ``toy'' language (used by\nnovices\nor dilettantes), and so forth. As can be seen from the historical remarks in my Principles, social factors are\nfrequently more important than scientific factors in determining the success or failure of a programming\nlanguage. \n\nOften economic issues can be quantified in terms of money, but the monetary values of costs and benefits are\noften\nunstable and unpredictable because they depend on changing market forces. Also, many social issues, from\ndissatisfaction with poorly designed software to human misery resulting from system failures, are inaccurately\nrepresented by the single dimension of monetary cost. All kinds of ``cost'' and ``benefit'' must be considered\nin\nseeking an economical design. \n\n\nElegance Symbolizes Good Design\n\n``Elegance? Who cares about elegance?'' snorts the hard-nosed engineer, but Billington shows clearly the\ncritical\nrole of elegance in ``hard-nosed'' engineering. \n\nFor the Designer\n\nIt is well-known that feature interaction poses a serious problem for language designers because of the\ndifficulty\nof analyzing all the possible interactions of features in a language (see my Principles for examples).\nStructural\nengineers face similar problems of analytic complexity, but Billington observes that the best designers don't\nmake\nextensive use of computer models and calculation. \n\nOne reason is that mathematical analysis is always incomplete. The engineer must make a decision about which\nvariables are significant and which are not, and an analysis may lead to incorrect conclusions if this\ndecision is not\nmade well. Also, equations are often simplified (e.g., made linear) to make their analysis feasible, and this\nis\nanother potential source of error. Because of these limitations, engineers that depend on mathematical\nanalysis\nmay overdesign a structure to compensate for unforeseen effects left out of the analysis. Thus the price of\nsafety is\nadditional material and increased cost (i.e. decreased efficiency and economy). \n\nSimilarly in programming language design, the limitations of the analytic approach often force us to make a\nchoice between an under-engineered design, in which we run the risk of unanticipated interactions, and an\nover-engineered design, in which we have confidence, but which is inefficient or uneconomical. \n\nMany people have seen the famous film of the collapse in 1940 of the four-month-old Tacoma Narrows bridge; it\nvibrated itself to pieces in a storm because aerodynamical stability had not been considered in its design.\nBillington explains that this accident, along with a number of less dramatic bridge failures, was a\nconsequence of\nan increasing use of theoretical analyses that began in the 1920s. However, the very problem that destroyed\nthe\nTacoma Narrows bridge had been anticipated and avoided a century before by bridge designers who were guided\nby aesthetic principles. \n\nAccording to Billington, the best structural engineers do not rely on mathematical analysis (although they do\nnot\nabandon it altogether). Rather, their design activity is guided by a sense of elegance. This is because\nsolutions to\nstructural engineering problems are usually greatly underdetermined, that is, there are many possible\nsolutions to a\nparticular problem, such as bridging a particular river. Therefore, expert designers restrict their attention\nto\ndesigns in which the interaction of the forces is easy to see. The design looks unbalanced if the forces are\nunbalanced, and the design looks stable if it is stable. \n\nThe general principle is that designs that look good will also be good, and therefore the design process can\nbe\nguided by aesthetics without extensive (but incomplete) mathematical analysis. Billington expresses this idea\nby\ninverting the old architectural maxim and asserting that, in structural design, function follows form. He adds\n(p.\n21), ``When the form is well chosen, its analysis becomes astoundingly simple.'' In other words, the choice of\nform is open and free, so we should pick forms where elegant design expresses good design (i.e. efficient and\neconomical design). If we do so, then we can let aesthetics guide design. \n\nThe same applies to programming language design. By restricting our attention to designs in which the\ninteraction\nof features is manifest - in which good interactions look good, and bad interactions look bad - we can let our\naesthetic sense guide our design and we can be much more confident that we have a good design, without having\nto\ncheck all the possible interactions. \n\nFor the User\n\nIn this case, what's good for the designer also is good for the user. Nobody is comfortable crossing a bridge\nthat\nlooks like it will collapse at any moment, and nobody is comfortable using a programming language in which\nfeatures may ``explode'' if combined in the wrong way. The manifest balance of forces in a well-designed\nbridge\ngives us confidence when we cross it. So also, the manifestly good design of our programming language should\nreinforce our confidence when we program in it, because we have (well-justified) confidence in the\nconsequences\nof our actions. \n\nWe accomplish little by covering an unbalanced structure in a beautiful facade. When the bridge is unable to\nsustain the load for which it was designed, and collapses, it won't much matter that it was beautiful on the\noutside.\nSo also in programming languages. If the elegance is only superficial, that is, if it is not the manifestation\nof a\ndeep coherence in the design, then programmers will quickly see through the illusion and loose their\n(unwarranted)\nconfidence. \n\nIn summary, good designers choose to work in a region of the design space where good designs look good. As a\nconsequence, these designers can rely on their aesthetic sense, as can the users of the structures (bridges or\nprogramming languages) they design. We may miss out on some good designs this way, but they are of limited\nvalue unless both the designer and the user can be confident that they are good designs. We may summarize the\npreceding discussion in a maxim analogous to those in my Principles of Programming Languages: \n                                The Elegance Principle\n\n              Confine your attention to designs that look good because they are good. \n\n\n\nThe Programming Language as Work Environment\n\nThere are other reasons that elegance is relevant to a well-engineered programming language. The programming\nlanguage is something the professional programmer will live with - even live in. It should feel comfortable\nand\nsafe, like a well-designed home or office; in this way it can contribute to the quality of the activities that\ntake\nplace within it. Would you work better in an oriental garden or a sweatshop? \n\nA programming language should be a joy to use. This will encourage its use and decrease the programmer's\nfatigue\nand frustration. The programming language should not be a hindrance, but should serve more as a collaborator,\nencouraging programmers to do their jobs better. As some automobiles are ``driving machines'' and work as a\nnatural extension of the driver, so a programming language should be a ``programming machine'' by encouraging\nthe programmer to acquire the smooth competence and seemingly effortless skill of a virtuoso. The programming\nlanguage should invite the programmer to design elegant, efficient and economical programs. \n\nThrough its aesthetic dimension a programming language symbolizes many values. For example, in the variety of\nits features it may symbolize profligate excess, sparing economy or asceticism; the kind of its features may\nrepresent intellectual sophistication, down-to-earth practicality or ignorant crudeness. Thus a programming\nlanguage can promote a set of values. By embodying certain values, it encourages us to think about them; by\nneglecting or negating other values, it allows them to recede into the background and out of our attention.\nOut of\nsight, out of mind. \n\n\nAcquiring a Sense of Elegance\n\nAesthetics is notoriously difficult to teach, so you may wonder how you are supposed to acquire that refined\nsense\nof elegance necessary to good design. Billington observes that this sense is acquired through extensive\nexperience\nin design, which, especially in Europe, is encouraged by a competitive process for choosing bridge designers.\nBecause of it, structural engineers design many more bridges than they build, and they learn from each\ncompetition they loose by comparing their own designs with those of the winner and other losers. The public\nalso\ncritiques the competing designs, and in this way becomes more educated; their sense of elegance develops along\nwith that of the designers. \n\nSo also, to improve as a programming language designer you should design many languages - design obsessively -\nand criticize, revise and discard your designs. You should also evaluate and criticize other people's designs\nand try\nto improve them. In this way you will acquire the body of experience you will need when the ``real thing''\ncomes\nalong. \n\n\nReferences\n\n   1.Billington, David P., The Tower and the Bridge: The New Art of Structural Engineering, Princeton:\n     Princeton University Press, 1983. Chapters 1 and 6 are the most relevant. \n\n   2.MacLennan, Bruce J., Principles of Programming Languages: Design, Evaluation, and Implementation,\n     second edition, New York: Holt, Rinehart & Winston (now Oxford University Press), 1987.\n\n\n"}