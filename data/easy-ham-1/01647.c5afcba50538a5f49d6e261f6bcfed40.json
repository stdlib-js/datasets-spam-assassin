{"id":"01647","group":"easy-ham-1","checksum":{"type":"MD5","value":"c5afcba50538a5f49d6e261f6bcfed40"},"text":"Return-Path: skip@pobox.com\nDelivery-Date: Fri Sep  6 16:01:51 2002\nFrom: skip@pobox.com (Skip Montanaro)\nDate: Fri, 6 Sep 2002 10:01:51 -0500\nSubject: [Spambayes] Deployment\nIn-Reply-To: <200209061431.g86EVM114413@pcp02138704pcs.reston01.va.comcast.net>\nReferences: <200209061431.g86EVM114413@pcp02138704pcs.reston01.va.comcast.net>\nMessage-ID: <15736.50015.881231.510395@12-248-11-90.client.attbi.com>\n\n\n    Guido> Takers?  How is ESR's bogofilter packaged?  SpamAssassin?  The\n    Guido> Perl Bayes filter advertised on slashdot?\n\nDunno about the other tools, but SpamAssassin is a breeze to incorporate\ninto a procmail environment.  Lots of people use it in many other ways.  For\nperformance reasons, many people run a spamd process and then invoke a small\nC program called spamc which shoots the message over to spamd and passes the\nresult back out.  I think spambayes in incremental mode is probably fast\nenough to not require such tricks (though I would consider changing the\npickle to an anydbm file).\n\nBasic procmail usage goes something like this:\n\n    :0fw\n    | spamassassin -P\n\n    :0\n    * ^X-Spam-Status: Yes\n    $SPAM\n\nWhich just says, \"Run spamassassin -P reinjecting its output into the\nprocessing stream.  If the resulting mail has a header which begins\n\"X-Spam-Status: Yes\", toss it into the folder indicated by the variable\n$SPAM.\n\nSpamAssassin also adds other headers as well, which give you more detail\nabout how its tests fared.  I'd like to see spambayes operate in at least\nthis way: do its thing then return a message to stdout with a modified set\nof headers which further processing downstream can key on.\n\nSkip\n\n"}