{"id":"00212","group":"hard-ham-1","checksum":{"type":"MD5","value":"1459a647a827cc74ab6821fb2e9c8c93"},"text":"Return-Path: env_216095411795471888@hermes.sun.com\nDelivery-Date: Sun Sep 15 00:03:33 2002\nReturn-Path: <env_216095411795471888@hermes.sun.com>\nReceived: from localhost (localhost.localdomain [127.0.0.1])\n\tby mothlight.dyndns.org (8.11.6/8.11.6) with ESMTP id g8F40qh03708\n\tfor <nice@localhost>; Sun, 15 Sep 2002 00:00:52 -0400\nReceived: from fastmail.fm [209.61.183.86]\n\tby localhost with IMAP (fetchmail-5.9.0)\n\tfor nice@localhost (single-drop); Sun, 15 Sep 2002 00:00:52 -0400 (EDT)\nReceived: from www.fastmail.fm (server1.internal [10.202.2.132])\n\tby server2.fastmail.fm (Cyrus v2.1.5) with LMTP; Tue, 10 Sep 2002 12:38:41 -0500\nX-Sieve: CMU Sieve 2.2\nReceived: from www.fastmail.fm (server1.internal [10.202.2.132])\n\tby www.fastmail.fm (Cyrus v2.1.3) with LMTP; Tue, 10 Sep 2002 12:38:41 -0500\nReceived: from www.fastmail.fm (localhost [127.0.0.1])\n\tby localhost.localdomain (Postfix) with ESMTP id B97BF6DAE2\n\tfor <mothlight@fastmail.fm>; Tue, 10 Sep 2002 12:38:27 -0500 (CDT)\nX-Mail-from: env_216095411795471888@hermes.sun.com\nX-Delivered-to: <mothlight@fastmail.fm>\nX-Spam: spam\n  HTTP_CTRL_CHARS_HOST, UNSUB_PAGE, SUPERLONG_LINE, MAILTO_LINK, WEB_BUGS,\n  NO_MX_FOR_FROM, CTYPE_JUST_HTML\nReceived: from hermes.sun.com (hermes.sun.com [64.124.140.169])\n\tby www.fastmail.fm (Postfix) with SMTP id 2604B6DB18\n\tfor <mothlight@fastmail.fm>; Tue, 10 Sep 2002 12:38:27 -0500 (CDT)\nDate: 10 Sep 2002 08:24:12 -0800\nFrom: \"JDC Tech Tips\" <body_216095411795471888@hermes.sun.com>\nTo: mothlight@fastmail.fm\nMessage-Id: <216095411795471888@hermes.sun.com>\nSubject: Core Java Technologies Tech Tips, September 10, 2002 (ArrayList vs. LinkedList, Zero-Length Arrays)\nMime-Version: 1.0\nContent-Type: text/html; charset=us-ascii\nContent-Transfer-Encoding: 7bit\nX-Mailer: SunMail 1.0\nX-Status: \nX-Keywords:                  \n\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html>\n<head>\n<title>\nCore Java Technologies Technical Tips\n</title>\n\n<style type=\"text/css\">\n\nCODE {color: #333333; font-family: Verdana, Courier, Monospace; font-size: 10pt}\nPRE {color: #333333; font-family: Verdana, Courier, Monospace; font-size: 10pt}\nBODY, div, span {color: #333333; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\ntd, th {color: #333333; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\ntr {color: #333333; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\ntable {font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\np {color: #333333; font-family: arial,helvetica,sans-serif; font-size: 10pt}\nli {color: #333333; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\nbr {color: #333333; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\ndiv {color: #666699; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\nsup {font-family: Arial, Helvetica, sans-serif; font-size: 5pt}\nh3 {color: #666699; font-family: Arial, Helvetica, sans-serif; font-size: 11pt}\nh4, h5, h6 {color: #333333; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\nblockquote, input, select {color: #333333; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\nul, ol, font {color: #333333; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\na:link {font-size: 10pt; font-family: Arial, Helvetica, sans-serif; color:#666699 }\nspan.purple {font-weight: bold; color: #666699; font-family: Arial, Helvetica, sans-serif; font-size: 10pt}\nspan.small {font-size: 8pt; font-family: Arial, Helvetica, sans-serif; color:#333333 }\nspan.link {font-size: 8pt; font-family: Arial, Helvetica, sans-serif; color:#666699 }\n</style>\n\n</head>\n\n<body bgcolor=\"#ffffff\">\n<a name=\"top\"></a>\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"611\">\n<tr>\n<td colspan=\"3\" bgcolor=\"#cccccc\" width=\"1\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" border=\"0\" alt=\"image\"></td>\n</tr>\n\n<tr>\n<td bgcolor=\"#cccccc\" width=\"1\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" border=\"0\" alt=\"image\"></td>\n\n<td>\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"611\">\n<tr>\n<td colspan=\"2\">\n<img src=\"http://developer.java.sun.com/images/headers/core_ttips_hdr.jpg\" width=\"611\" height=\"160\" alt=\"Core Java Technologies Technical Tips\" border=\"0\"></td>\n</tr>\n\n<tr>\n<td colspan=\"2\" bgcolor=\"#cccccc\" width=\"1\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" border=\"0\" alt=\"image\"></td>\n</tr>\n\n<!-- ================== -->\n<!-- Start Main Content -->\n<!-- ================== -->\n\n<tr>\n<td height=\"20\">&nbsp;&nbsp;&nbsp;<a href=\"http://developer.java.sun.com/developer/TechTips/txtarchive/2002/Sept02_GlenM.txt?s=04&w=37\" style=\"text-decoration:none;\">View this issue as simple text</a></td>\n<td align=\"right\" height=\"20\"><span class=\"purple\">September 10, 2002</span>&nbsp;&nbsp;&nbsp;&nbsp;</td>\n</tr>\n\n<tr><td colspan=\"2\">\n\n\n\n<FORM METHOD=\"GET\" ACTION=\"http://search.java.sun.com/search/java/\">\n<table border=\"0\" cellpadding=\"10\" cellspacing=\"0\" width=\"100%\">\n<tr>\n<td>\n        \n<table border=\"0\" cellpadding=\"10\" cellspacing=\"0\" width=\"100%\">\n<tr> \n<td align=\"left\" VALIGN=\"middle\" width=\"20%\"><h3>In this Issue</h3></td>\n              \n<td valign=\"middle\" align=\"right\" width=\"65%\">\n<font size=\"2\">\n<INPUT TYPE=\"text\" SIZE=\"15\" MAXLENGTH=\"128\" NAME=qt></FONT></td>\n            \n<td VALIGN=\"middle\" WIDTH=\"55\">\n<INPUT TYPE=\"image\" SRC=\"http://developer.java.sun.com/images/search.button.gif\" ALT=\"Search\" value=\"search\" BORDER=\"0\" WIDTH=\"55\"></td>\n</tr>\n</table>\n\n</FORM>\n\n<p>\nWELCOME to the Core Java<sup>TM</sup> Technologies Tech Tips, September 10, 2002. Here you'll get tips on using core Java technologies and APIs, such as those in Java 2 Platform, Standard Edition (J2SE<sup>TM</sup>).\n</p>\n\n<p>\n<a href=\"#1\"><img src=\"http://developer.java.sun.com/images/anchor.gif\" border=\"0\" alt=\"\">Using ArrayList and LinkedList</a>\n<br>    \n<a href=\"#2\"><img src=\"http://developer.java.sun.com/images/anchor.gif\" border=\"0\" alt=\"\">Using Zero-Length Arrays</a>\n</p>\n\n<p>\nThese tips were developed using Java 2 SDK, Standard Edition, v 1.4.\n</p>\n\n<p>\nThis issue of the JDC Tech Tips is written by Glen McCluskey.\n</p>\n\n<table width=\"100%\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\">\n\n<!-- Grey Horizontal Line Begins Here -->\n\n<tr>\n<td bgcolor=\"#cccccc\" height=\"1\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" ALT=\"Pixel\" border=\"0\"></td>\n</tr>\n</table> \n\n<!-- Grey Horizontal Line ends Here -->\n\n<a name=\"1\"></a>\n\n<h3>USING ARRAYLIST AND LINKEDLIST</h3>\n\n<p>\n<code>ArrayList</code> and <code>LinkedList</code> are two <code>Collections</code> classes used for storing lists of object references. For example, you could have an <code>ArrayList</code> of Strings, or a <code>LinkedList</code> of Integers. This tip compares the performance of <code>ArrayList</code> and <code>LinkedList</code>, and offers some suggestions about which of these classes is the right choice in a given situation.\n</p>\n\n<p>\nThe first key point is that an <code>ArrayList</code> is backed by a primitive <code>Object</code> array. Because of that, an <code>ArrayList</code> is much faster than a <code>LinkedList</code> for random access, that is, when accessing arbitrary list elements using the <code>get</code> method. Note that the <code>get</code> method is implemented for <code>LinkedLists</code>, but it requires a sequential scan from the front or back of the list. This scan is very slow. For a <code>LinkedList</code>, there's no fast way to access the Nth element of the list.\n</p>\n\n\n<p>\nConsider the following example. Suppose you have a large list of sorted elements, either an <code>ArrayList</code> or a <code>LinkedList</code>. Suppose too that you do a binary search on the list. The standard binary search algorithm starts by checking the search key against the value in the middle of the list. If the middle value is too high, then the upper half of the list is eliminated. However, if the middle value is too low, then the lower half of the list is ignored. This process continues until the key is found in the list, or until the lower bound of the search becomes greater than the upper bound.\n</p>\n\n<p>\nHere's a program that does a binary search on all the elements in an <code>ArrayList</code> or a <code>LinkedList</code>:\n</p>\n\n<pre>\n    import java.util.*;\n\n    public class ListDemo1 {\n        static final int N = 10000;\n\n        static List values;\n\n        // make List of increasing Integer values\n\n        static {\n           Integer vals[] = new Integer[N];\n\n           Random rn = new Random();\n\n           for (int i = 0, currval = 0; i &lt; N; i++) {\n               vals[i] = new Integer(currval);\n               currval += rn.nextInt(100) + 1;\n           }\n\n           values = Arrays.asList(vals);\n        }\n        \n        // iterate across a list and look up every\n        // value in the list using binary search\n\n        static long timeList(List lst) {\n            long start = System.currentTimeMillis();\n\n            for (int i = 0; i &lt; N; i++) {\n\n               // look up a value in the list \n               // using binary search\n\n               int indx = Collections.binarySearch(\n                                   lst, values.get(i));\n\n               // sanity check for result \n               // of binary search\n\n               if (indx != i) {\n                   System.out.println(\n                                    &quot;*** error ***\\n&quot;);\n               }\n           }\n\n           return System.currentTimeMillis() - start;\n       }\n\n       public static void main(String args[]) {\n\n           // do lookups in an ArrayList \n\n           System.out.println(&quot;time for ArrayList = &quot; +\n               timeList(new ArrayList(values)));\n\n           // do lookups in a LinkedList\n\n           System.out.println(\n               &quot;time for LinkedList = &quot; +\n               timeList(new LinkedList(values)));\n       }\n    }\n</pre>\n\n<p>\nThe <code>ListDemo1</code> program sets up a <code>List</code> of sorted Integer values. It then adds the values to an <code>ArrayList</code> or a <code>LinkedList</code>. Then <code>Collections.binarySearch</code> is used to search for each value in the \nlist.\n</p>\n\n<p>\nWhen you run this program, you should see a result that looks something like this:\n</p>\n\n<pre>\n    time for ArrayList = 31\n\n    time for LinkedList = 4640\n</pre>\n\n<p>\n<code>ArrayList</code> is about 150 times faster than <code>LinkedList</code>. (Your results might differ depending on your machine characteristics, but you should see a distinct difference in the result for <code>ArrayList</code> as compared to that for <code>LinkedList</code>. The same is true for the other programs in this tip.) Clearly, <code>LinkedList</code> is a bad choice in this situation. The binary search algorithm inherently uses random access, and <code>LinkedList</code> does not support fast random access. The time to do a random access in a <code>LinkedList</code> is proportional to the size of the list. By comparison, random access in an <code>ArrayList</code> has a fixed time.\n</p>\n\n<p>\nYou can use the <code>RandomAccess</code> marker interface to check whether a List supports fast random access:\n</p>\n\n<pre>\n    void f(List lst) {\n        if (lst instanceof RandomAccess) {\n            // supports fast random access\n        }\n    }\n</pre>\n\n<p>\n<code>ArrayList</code> implements the <code>RandomAccess</code> interface, and <code>LinkedList</code>. does not. Note that <code>Collections.binarySearch</code> does take advantage of the <code>RandomAccess</code> property, to optimize searches.\n</p>\n\n<p>\nDo these results prove that <code>ArrayList</code> is always a better choice? Not necessarily. There are many cases where <code>LinkedList</code> does better. Also note that there are many situations where an algorithm can be implemented efficiently for <code>LinkedList</code>. An example is reversing a <code>LinkedList</code> using <code>Collections.reverse</code>. The internal algorithm does this, and gets reasonable performance, by using forward and backward iterators.\n</p>\n\n<p>\nLet's look at another example. Suppose you have a list of elements, and you do a lot of element inserting and deleting to the list. In this case, <code>LinkedList</code> is the better choice. To demonstrate that, consider the following &quot;worst case&quot; scenario. In this demo, a program repeatedly inserts elements at the beginning of a list. The code looks like this:\n</p>\n\n<pre>\n    import java.util.*;\n\n    public class ListDemo2 {\n        static final int N = 50000;\n\n        // time how long it takes to add \n        // N objects to a list\n\n        static long timeList(List lst) {\n            long start = System.currentTimeMillis();\n\n            Object obj = new Object();\n\n            for (int i = 0; i &lt; N; i++) {\n                lst.add(0, obj);\n            }\n\n            return System.currentTimeMillis() - start;\n        }\n\n        public static void main(String args[]) {\n\n            // do timing for ArrayList\n\n            System.out.println(\n                &quot;time for ArrayList = &quot; +\n                timeList(new ArrayList()));\n\n            // do timing for LinkedList\n\n            System.out.println(\n                &quot;time for LinkedList = &quot; +\n                timeList(new LinkedList()));\n        }\n    } \n</pre>\n\n<p>\nWhen you run this program, the result should look something like this:\n</p>\n\n<pre>\n    time for ArrayList = 4859\n\n    time for LinkedList = 125\n</pre>\n\n<p>\nThese results are pretty much the reverse of the previous example.\n</p>\n\n<p>\nWhen an element is added to the beginning of an <code>ArrayList</code>, all of the existing elements must be pushed back, which means a lot of expensive data movement and copying. By contrast, adding an element to the beginning of a <code>LinkedList</code> simply means allocating an internal record for the element and then adjusting a couple of links. Adding to the beginning of a <code>LinkedList</code> has fixed cost, but adding to the beginning of an <code>ArrayList</code> has a cost that's proportional to the list size.\n</p>\n\n<p>\nSo far, this tip has looked at speed issues, but what about space? Let's look at some internal details of how <code>ArrayList</code> and <code>LinkedList</code> are implemented in Java 2 SDK, Standard Edition v 1.4. These details are not part of the external specification of these classes, but are illustrative of how such classes work internally.\n</p>\n\n<p>\nThe <code>LinkedList</code> class has a private internal class defined like this:\n</p>\n\n<pre>\n    private static class Entry {\n        Object element;\n        Entry next;\n        Entry previous;\n    } \n</pre>\n\n\n<p>\nEach <code>Entry</code> object references a list element, along with the next and previous elements in the <code>LinkedList</code> -- in other words, a doubly-linked list. A <code>LinkedList</code> of 1000 elements will have 1000 <code>Entry</code> objects linked together, referencing the actual list elements. There is significant space overhead in a <code>LinkedList</code> structure, given all these <code>Entry</code> objects.\n</p>\n\n<p>\nAn <code>ArrayList</code> has a backing <code>Object</code> array to store the elements. This array starts with a capacity of 10. When the array needs to grow, the new capacity is computed as:\n</p>\n\n<pre>\n    newCapacity = (oldCapacity * 3) / 2 + 1;\n</pre>\n\n<p>\nNotice that the array capacity grows each time by about 50%. This means that if you have an <code>ArrayList</code> with a large number of elements, there will be a significant amount of space wasted at the end. This waste is intrinsic to the way <code>ArrayList</code> works. If there was no spare capacity, the array would have to be reallocated for each new element, and performance would suffer dramatically. Changing the growth strategy to be more aggressive (such as doubling the size at each reallocation) would result in slightly better performance, but it would waste more space.\n</p>\n\n<p>\nIf you know how many elements will be in an <code>ArrayList</code>, you can specify the capacity to the constructor. You can also call the <code>trimToSize</code> method after the fact to reallocate the internal array. This gets rid of the wasted space.\n</p>\n\n<p>\nSo far, this discussion has assumed that either an <code>ArrayList</code> or a <code>LinkedList</code> is &quot;right&quot; for a given application. But sometimes, other choices make more sense. For example, consider the very common situation where you have a list of key/value pairs, and you would like to retrieve a value for a given key.\n</p>\n\n<p>\nYou could store the pairs in an N x 2 <code>Object</code> array. To find the right pair, you could do a sequential search on the key values. This approach works, and is a useful choice for very small lists (say 10 elements or less), but it doesn't scale to big lists.\n</p>\n\n<p>\nAnother approach is to sort the key/value pairs by ascending key value, store the result in a pair of <code>ArrayLists</code>, and then do a binary search on the keys list. This approach also works, and is very fast. Yet another approach is to not use a list structure at all, but instead use a map structure (hash table), in the form of a <code>HashMap</code>.\n</p>\n\n<p>\nWhich is faster, a binary search on an <code>ArrayList</code>, or a <code>HashMap</code>? Here's a final example that compares these two:\n</p>\n\n<pre>\n    import java.util.*;\n\n    public class ListDemo3 {\n        static final int N = 500000;\n\n        // Lists of keys and values\n\n        static List keys;\n        static List values;\n\n        // fill the keys list with ascending order key \n        // values and fill the values list with\n        // corresponding values (-key)\n\n        static {\n            Integer keyvec[] = new Integer[N];\n            Integer valuevec[] = new Integer[N];\n\n            Random rn = new Random();\n\n            for (int i = 0, currval = 0; i &lt; N; i++) {\n                keyvec[i] = new Integer(currval);\n                valuevec[i] = new Integer(-currval);\n                currval += rn.nextInt(100) + 1;\n            }\n\n            keys = Arrays.asList(keyvec);\n            values = Arrays.asList(valuevec);\n        }\n\n        // fill a Map with key/value pairs\n\n        static Map map = new HashMap();\n\n        static {\n            for (int i = 0; i &lt; N; i++) {\n                map.put(keys.get(i), values.get(i));\n            }\n        }\n\n        // do binary search lookup of all keys\n\n        static long timeList() {\n            long start = System.currentTimeMillis();\n\n            for (int i = 0; i &lt; N; i++) {\n                int indx = Collections.binarySearch(\n                                    keys, keys.get(i));\n\n                // sanity check of returned value \n                // from binary search\n\n                if (indx != i) {\n                    System.out.println(\n                                    &quot;*** error ***\\n&quot;);\n                }\n            }\n\n            return System.currentTimeMillis() - start;\n        }\n\n        // do Map lookup of all keys\n\n        static long timeMap() {\n            long start = System.currentTimeMillis();\n\n            for (int i = 0; i &lt; N; i++) {\n                Integer value = (Integer)map.get(\n                                          keys.get(i));\n\n                // sanity check of value returned \n                // from map lookup\n\n                if (value != values.get(i)) {\n                    System.out.println(\n                                    &quot;*** error ***\\n&quot;);\n                }\n            }\n\n            return System.currentTimeMillis() - start;\n        }\n\n        public static void main(String args[]) {\n\n            // do timing for List implementation\n\n            System.out.println(\"List time = \" + \n                                           timeList());\n\n            // do timing for Map implementation\n\n            System.out.println(&quot;Map time = &quot; + \n                                            timeMap());\n        }\n    }\n</pre>\n\n<p>\nThe program sets up <code>Lists</code> of keys and values, and then uses two different techniques to map keys to values. One approach uses a binary search on a list, the other a hash table.\n</p>\n\n<p>\nWhen you run the <code>ListDemo3</code> program, you should get a result that looks something like this:\n</p>\n\n<pre>\n    ArrayList time = 1000\n\n    HashMap time = 281\n</pre>\n\n<p>\nIn this example, N has a value of 500000. Approximately, log2(N) - 1 comparisons are required in an average successful binary search, so each binary search lookup in the <code>ArrayList</code> will take about 18 comparisons. By contrast, a properly implemented hash table typically requires only 1-3 comparisons. So you should expect the hash table to be faster in this case.\n</p>\n\n<p>\nHowever, binary search is still useful. For example, you might want to do a lookup in a sorted list and then find keys that are close in value to the key used for the lookup. Doing this is easy with binary search, but impossible in a hash table. Keys in a hash table are stored in apparent random order. Also, if you are concerned with worst-case performance, the binary search algorithm offers a much stronger performance guarantee than a hash table scheme. You might also consider using TreeMap for doing lookups in sorted collections of key/value pairs.\n</p>\n\n<p>\nLet's summarize the key points presented in this tip:\n</p>\n\n<ul>\n  <li>Appending elements to the end of a list has a fixed averaged cost for both <code>ArrayList</code> and <code>LinkedList.</code> For <code>ArrayList</code>, appending typically involves setting an internal array location to the element reference, but occasionally results in the array being reallocated. For <code>LinkedList</code>, the cost is uniform and involves allocating an internal <code>Entry</code> object.</li>\n\n  <li>Inserting or deleting elements in the middle of an <code>ArrayList</code> implies that the rest of the list must be moved. Inserting or deleting elements in the middle of a <code>LinkedList</code> has fixed cost.</li>\n\n  <li>A <code>LinkedList</code> does not support efficient random access</li>\n\n  <li>An <code>ArrayList</code> has space overhead in the form of reserve capacity at the end of the list. A <code>LinkedList</code> has significant space overhead per element.</li>\n\n  <li>Sometimes a <code>Map</code> structure is a better choice than a <code>List</code>.</li>\n</ul>\n\n<p>\nFor more information about Using <code>ArrayList</code> and <code>LinkedLists</code>, see section 16.6, List, and section 16.7, Map and SortedMap, in &quot;<a href=\"http://java.sun.com/docs/books/javaprog/thirdedition/?s=04&w=37\" target=\"_blank\">The Java<sup>TM</sup> Programming Language Third Edition</a>&quot; by Arnold, Gosling, and Holmes. Also see the <a href=\"http://java.sun.com/docs/books/tutorial/collections/?s=04&w=37\" target=\"_blank\">Collections trail in the Java Tutorial, Third Edition</a>.\n</p>\n\n<table width=\"100%\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\">\n<tr>\n<td>\n<div align=\"right\">\n<a href=\"#top\">back to top<img src=\"http://developer.java.sun.com/images/back_to_top.gif\" border=\"0\" alt=\"Pixel\"></a>\n</div>\n</td></tr>\n\n<tr><td bgcolor=\"#ffffff\" height=\"2\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" ALT=\"Pixel\" border=\"0\"></td></tr>\n\n<!-- Grey Horizontal Line Begins Here -->\n\n<tr>\n<td bgcolor=\"#cccccc\" height=\"1\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" ALT=\"Pixel\" border=\"0\"></td>\n</tr>\n</table> \n\n<!-- Grey Horizontal Line ends Here -->\n\n<a name=\"2\"></a>\n\n<h3>USING ZERO-LENGTH ARRAYS</h3>\n\n<p>\nSuppose that you are writing a Java application that involves some sort of data filtering. You have some raw data that you want to clean up and process in various ways. One of the methods you've written takes an array of integers, along with minimum and maximum values. The method goes through the array and eliminates &quot;outliers,&quot; that is, values that are too small or too big. The result of the filtering process is a new array of cleaned-up data.\n</p>\n\n<p>\nHow could you implement this kind of filtering method? Here's one approach:\n</p>\n\n<pre>\n    import java.util.*;\n    \n    public class ZeroDemo1 {\n    \n        // filter input array and throw away values \n        // that are less than minval or greater than \n        // maxval\n    \n        static int[] filterData(\n                int indata[], int minval, int maxval) {\n    \n            // check parameters for errors \n    \n            if (indata == null) {\n                throw new NullPointerException(\n                                     &quot;indata is null&quot;);\n            }\n            if (maxval &lt; minval) {\n                throw new IllegalArgumentException(\n                &quot;maxval &lt; minval&quot;);\n            }\n    \n            // count number of valid values \n            // in input array\n    \n            int validcnt = 0;\n            for (int i = 0; i &lt; indata.length; i++) {\n                if (indata[i] &gt;= minval &amp;&amp; indata[i] \n                                         &lt;= maxval) {\n                    validcnt++;\n                }\n            }\n    \n            // if no valid values, return null\n    \n            if (validcnt == 0) {\n                return null;\n            }\n    \n            // copy valid values to new array \n            // and return it\n    \n            int outdata[] = new int[validcnt];\n            for (int i = 0, j = 0; \n                              i &lt; indata.length; i++) {\n                if (indata[i] &gt;= minval &amp;&amp; indata[i] \n                                           &lt;= maxval) {\n                    outdata[j++] = indata[i];\n                }\n            }\n            return outdata;\n        }\n    \n        public static void main(String args[]) {\n    \n            // set up test array of integers\n    \n            int indata[] = new int[]{1, 3, -17, 8, 59};\n    \n            // filter out values not in the range 1-10\n    \n            int outdata1[] = filterData(indata, 1, 10);\n            for (int i = 0; i &lt; outdata1.length; i++) {\n                System.out.println(outdata1[i]);\n            }\n    \n            // filter out values not \n            // in the range 100-200\n    \n            int outdata2[] = filterData(\n                                     indata, 100, 200);\n            for (int i = 0; i &lt; outdata2.length; i++) {\n                System.out.println(outdata2[i]);\n            }\n        }\n    }\n</pre>\n\n<p>\nThe <code>filterData</code> method does two scans of the input array. The first scan counts the number of valid data values. Then the method allocates a new array of the appropriate size, and copies the good values to it. If there are no good values, the method returns a null value for the array reference.\n</p>\n\n<p>\nThe result of running the <code>ZeroDemo1</code> program is:\n</p>\n\n<pre>\n    1\n    3\n    8\n    Exception in thread &quot;main&quot;\n    java.lang.NullPointerException\n        at ZeroDemo1.main(ZeroDemo1.java:72)\n</pre>\n\n<p>\nThe problem with this program is a rather basic one. The second call of <code>filterData</code> returns a null value, and the program fails to take this possibility into account.\n</p>\n\n<p>\nA better approach in this example would be to comment out the block of code that tests for the possibility of no valid data values:\n</p>\n\n<pre>\n    /*\n    if (validcnt == 0) {\n        return null;\n    }\n    */\n</pre>\n\n<p>\nWhen there is no valid data, the code will fall through to the next line, where a zero-length array is allocated:\n</p>\n\n<pre>\n    int outdata[] = new int[0];\n</pre>\n\n<p>\nThis is perfectly legal Java usage. The representation of Java arrays includes the length of the array, and it's therefore possible to tell if an array has zero length.\n</p>\n\n<p>\nFor the <code>ZeroDemo1</code> example, if you anticipate that validcnt will often be zero, that is, data filtering will often eliminate all values from the input, then you could optimize away the second input scan by adding code like this:\n</p>\n\n<pre>\n    int outdata[] = new int[validcnt];\n    if (validcnt == 0) {\n        return outdata;\n    }\n</pre>\n\n<p>\nNote that usage such as:\n</p>\n\n<pre>\n    int outdata[] = new int[]{};\n</pre>\n\n<p>\nis also legal, to initialize an array with a zero-length set of integer constants.\n</p>\n\n<p>\nIn general, it's best not to return null from a method that returns an array type. Always returning an array, even if the array has zero length, greatly improves the generality of algorithms. If you anticipate that your methods will often return zero-length arrays, you might be concerned about the performance implications of allocating many such arrays. In this case, you can allocate a single array, and always return the same one, as follows:\n</p>\n\n<pre>\n    private static final int ZERO_LENGTH_ARRAY[] = \n                                            new int[0];\n</pre>\n\n<p>\nThis array is immutable (it can't be changed), and can be shared throughout your application.\n</p>\n\n<p>\nThere's another way that zero-length arrays are used, as illustrated in the following example:\n</p>\n\n<pre>\n    import java.util.*;\n    \n    public class ZeroDemo2 {\n        public static void main(String args[]) {\n    \n            // set up ArrayList and add strings to it\n    \n            List stringlist = new ArrayList();\n            stringlist.add(&quot;string 1&quot;);\n            stringlist.add(&quot;string 2&quot;);\n            stringlist.add(&quot;string 3&quot;);\n    \n            // convert to String array\n    \n            String out[] = (\n                          String[])stringlist.toArray(\n            new String[0]);\n            for (int i = 0; i &lt; out.length; i++) {\n                System.out.println(out[i]);\n            }\n        }\n    }\n</pre>\n\n<p>\nThe result of running the <code>ZeroDemo2</code> program is:\n</p>\n\n<pre>\n    string 1\n    string 2\n    string 3\n</pre>\n\n<p>\nThe <code>ZeroDemo2</code> program sets up an <code>ArrayList</code>, and adds three strings to it. Then the program calls <code>toArray</code> to get a <code>String</code> array of the three elements in the <code>ArrayList</code>. In this example, the argument to <code>toArray</code> is &quot;new String[0]&quot;. This argument serves a couple of purposes. First, if you have a <code>String</code> array that's big enough to hold the elements of the <code>ArrayList</code>, you can specify it as the argument to <code>toArray</code>. The method will use the <code>String</code> array.\n</p>\n\n<p>\nBut if your array is not big enough, then the <code>toArray</code> method allocates an array to return the elements. It uses the type of the array that was passed in to determine the type of the allocated array. <code>ArrayList</code> stores its element references in an <code>Object</code> array. The <code>toArray</code> method needs to be told if there is some other type (such as String) to be used for returning the array of elements. The method uses reflection (<code>java.lang.reflect.Array.newInstance</code>) to create an array of the appropriate type.\n</p>\n\n<p>\nFor more information about using zero-Length arrays, see item 27 &quot;Return zero-length arrays, not nulls&quot; in &quot;<a href=\"http://java.sun.com/docs/books/effective/?s=04&w=37\" target=\"_blank\">Effective Java Programming Language Guide</a>&quot; by Joshua Bloch.\n</p>\n\n<table width=\"100%\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\">\n<tr>\n<td>\n<div align=\"right\">\n<a href=\"#top\">back to top<img src=\"http://developer.java.sun.com/images/back_to_top.gif\" border=\"0\" alt=\"Pixel\"></a>\n</div>\n</td></tr>\n\n<tr><td bgcolor=\"#ffffff\" height=\"2\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" ALT=\"Pixel\" border=\"0\"></td></tr>\n\n<!-- Grey Horizontal Line Begins Here -->\n\n<tr>\n<td bgcolor=\"#cccccc\" height=\"1\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" ALT=\"Pixel\" border=\"0\"></td>\n</tr>\n</table> \n\n<!-- Grey Horizontal Line ends Here -->\n<br>\n\n<span class=\"small\">IMPORTANT: Please read our Terms of Use, Privacy, and Licensing policies:<br>\n<a href=\"http://www.sun.com/share/text/termsofuse.html?s=04&w=37\"><span class=\"link\">http://www.sun.com/share/text/termsofuse.html</span></a><br>\n<a href=\"http://www.sun.com/privacy/?s=04&w=37\"><span class=\"link\">http://www.sun.com/privacy/</span></a><br>\n<a href=\"http://developer.java.sun.com/berkeley_license.html?s=04&w=37\"><span class=\"link\">http://developer.java.sun.com/berkeley_license.html</span></a>\n</span><br><br>\n\n<span class=\"small\">\nComments? Send your feedback on the Java<sup>TM</sup> Technology Fundamentals Newsletter to: <a href=\"mailto:jdc-webmaster@sun.com\"><span class=\"link\">jdc-webmaster@sun.com</span></a>\n</span><br><br>\n\n<span class=\"small\">\nSubscribe to the following newsletters for the latest information about technologies and products in other Java platforms:\n</span><br><br>\n\n<span class=\"small\">\n  - Enterprise Java Technologies Tech Tips. Get tips on using\n    enterprise Java technologies and APIs, such as those in the\n    Java 2 Platform, Enterprise Edition (J2EE<sup>TM</sup>).<br>\n  - Wireless Developer Tech Tips. Get tips on using wireless\n    Java technologies and APIs, such as those in the Java 2 \n    Platform, Micro Edition (J2ME<sup>TM</sup>).<br><br>\n</span>\n   \n<span class=\"small\">\n  To subscribe to these and other JDC publications:<br>\n  - Go to the JDC Newsletters and Publications page, \n    choose the newsletters you want to <a href=\"http://developer.java.sun.com/subscription/?s=04&w=37\"><span class=\"link\">subscribe</span></a> to and click &quot;Update&quot;.<br>\n  - To unsubscribe, go to the <a href=\"http://developer.java.sun.com/subscription/?s=04&w=37\"><span class=\"link\">subscriptions page</span></a>, uncheck the appropriate checkbox, and click &quot;Update&quot;.\n</span><br><br>\n\n<span class=\"small\">ARCHIVES: You'll find the Core Java Technologies Tech Tips archives at:<br>\n<a href=\"http://java.sun.com/jdc/TechTips/?s=04&w=37\"><span class=\"link\">http://java.sun.com/jdc/TechTips/index.html</span></a>\n</span><br><br>\n\n<span class=\"small\">Copyright 2002 <a href=\"http://www.sun.com?s=04&w=37\"><span class=\"link\">Sun Microsystems, Inc.</span></a> All rights reserved. 901 San Antonio Road, Palo Alto, California 94303 USA.\n</span><br><br>\n\n\n<span class=\"small\">Sun, Sun Microsystems, Java, Java Developer Connection, J2SE, J2EE, and J2ME are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.\n</span><br><br>\n\n\n<!-- ================ -->\n<!-- End Main Content -->\n<!-- ================ -->\n\n<center>\n<a href=\"http://www.sun.com\"><img src=\"http://developer.java.sun.com/images/lgsun.gif\" border=\"0\" alt=\"Sun Microsystems, Inc.\"></a>\n</center>\n\n</td>\n</tr>\n</table>\n\n</td></tr>\n</table>\n</td>\n\n<td bgcolor=\"#cccccc\" width=\"1\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" border=\"0\" alt=\"\"></td>\n</tr>\n<tr>\n<td colspan=\"3\" bgcolor=\"#cccccc\" width=\"1\"><img src=\"http://developer.java.sun.com/images/pixel.gif\" width=\"1\" height=\"1\" border=\"0\" alt=\"\"></td>\n</tr>\n</table>\n\n<table bgcolor = \"#efefef\"><tr><td><a href=\"http://bulkmail.sun.com/servlet/PreferenceServlet?action=change&pref_name=content-type&pref_value=text&id=216095411795471888\">Please send me newsletters in text.</a><br><a href=\"http://bulkmail.sun.com/unsubscribe?216095411795471888\">Please unsubscribe me from this newsletter.</a><img src=\"http://bulkmail2.sun.com/OTServlet?id=216095411795471888\" width=1 height=1></td></tr></table></body>\n</html>\t\t\n\n"}